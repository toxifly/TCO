<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Battler - Roguelike Autobattler</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #0a0a0a;
            color: #eee;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        #game-container {
            width: 800px;
            max-width: 100%;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 28px;
            color: #ff5555;
            margin-bottom: 5px;
        }
        
        .battle-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 5px;
            background-color: #111;
        }
        
        .character {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #222;
        }
        
        .character.player {
            border-color: #5555ff;
        }
        
        .character.enemy {
            border-color: #ff5555;
        }
        
        .stats {
            display: flex;
            gap: 15px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-weight: bold;
            font-size: 18px;
        }
        
        .character-name {
            font-weight: bold;
            font-size: 20px;
        }
        
        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        .card {
            width: 120px;
            height: 170px;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
            background-color: #222;
            display: flex;
            flex-direction: column;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            cursor: pointer;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .card.attack {
            border-color: #ff5555;
        }
        
        .card.defense {
            border-color: #5555ff;
        }
        
        .card.skill {
            border-color: #55ff55;
        }
        
        .card-cost {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: #333;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .card-name {
            margin-top: 20px;
            font-weight: bold;
            text-align: center;
            font-size: 14px;
        }
        
        .card-description {
            margin-top: 10px;
            font-size: 12px;
            flex-grow: 1;
            text-align: center;
        }
        
        .card-type {
            text-align: center;
            font-size: 10px;
            font-style: italic;
            margin-top: 5px;
        }
        
        .log-container {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 20px;
            background-color: #111;
            font-size: 14px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            line-height: 1.3;
        }
        
        .log-player {
            color: #5555ff;
        }
        
        .log-enemy {
            color: #ff5555;
        }
        
        .log-system {
            color: #ffff55;
        }
        
        .log-reward {
            color: #55ff55;
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        button {
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #444;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .reward-container {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .reward-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        
        .game-over {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
        
        .animation {
            position: absolute;
            pointer-events: none;
        }
        
        .damage-text {
            position: absolute;
            color: #ff5555;
            font-weight: bold;
            animation: float-up 1s forwards;
        }
        
        .heal-text {
            position: absolute;
            color: #55ff55;
            font-weight: bold;
            animation: float-up 1s forwards;
        }
        
        @keyframes float-up {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }
        
        .floor-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            color: #ffff55;
        }
        
        .shake {
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        .flash {
            animation: flash 0.3s;
        }
        
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .deck-builder {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .deck-stats {
            margin-top: 15px;
            text-align: center;
        }
        
        .player-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }
        
        .player-stat {
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            min-width: 100px;
            text-align: center;
        }
        
        .stat-upgrade {
            margin-left: 5px;
            cursor: pointer;
            color: #55ff55;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="header">
            <h1>Card Battler</h1>
            <p>A Roguelike Autobattler Card Game</p>
        </div>
        
        <div class="floor-info" id="floor-info">Floor 1</div>
        
        <div class="battle-area">
            <div class="character enemy" id="enemy">
                <div class="character-name" id="enemy-name">Enemy</div>
                <div class="stats">
                    <div class="stat">
                        <div>HP</div>
                        <div class="stat-value" id="enemy-hp">30/30</div>
                    </div>
                    <div class="stat">
                        <div>Energy</div>
                        <div class="stat-value" id="enemy-energy">3/3</div>
                    </div>
                </div>
            </div>
            
            <div class="log-container" id="log-container">
                <div class="log-entry log-system">Welcome to Card Battler! Prepare for battle...</div>
            </div>
            
            <div class="character player" id="player">
                <div class="character-name" id="player-name">Adventurer</div>
                <div class="stats">
                    <div class="stat">
                        <div>HP</div>
                        <div class="stat-value" id="player-hp">50/50</div>
                    </div>
                    <div class="stat">
                        <div>Energy</div>
                        <div class="stat-value" id="player-energy">3/3</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="buttons">
            <button id="start-battle-btn">Start Battle</button>
            <button id="next-floor-btn" disabled>Next Floor</button>
            <button id="view-deck-btn">View Deck</button>
        </div>
        
        <div class="hand" id="player-hand">
            <!-- Cards will be added here dynamically -->
        </div>
        
        <div class="reward-container" id="reward-container">
            <h2>Choose Your Reward</h2>
            <div class="reward-options" id="reward-options">
                <!-- Reward cards will be added here dynamically -->
            </div>
        </div>
        
        <div class="game-over" id="game-over">
            <h2>Game Over</h2>
            <p id="game-over-message">You were defeated!</p>
            <button id="restart-btn">Play Again</button>
        </div>
        
        <div class="deck-builder" id="deck-builder">
            <h2>Your Deck</h2>
            <div class="player-stats" id="player-stats">
                <!-- Player stats will be added here -->
            </div>
            <div class="deck-stats" id="deck-stats">
                <!-- Deck stats will be added here -->
            </div>
            <div class="deck-grid" id="deck-grid">
                <!-- Deck cards will be added here -->
            </div>
            <button id="back-to-game-btn" style="margin-top: 20px;">Back to Game</button>
        </div>
    </div>
    
    <script>
        // Card definitions
        const CARD_TYPES = {
            ATTACK: 'attack',
            DEFENSE: 'defense',
            SKILL: 'skill'
        };
        
        // Basic card templates
        const CARD_TEMPLATES = [
            {
                id: 'strike',
                name: 'Strike',
                type: CARD_TYPES.ATTACK,
                cost: 1,
                description: 'Deal 6 damage.',
                rarity: 'common',
                effect: (game, source, target) => {
                    game.dealDamage(source, target, 6);
                }
            },
            {
                id: 'defend',
                name: 'Defend',
                type: CARD_TYPES.DEFENSE,
                cost: 1,
                description: 'Gain 5 block.',
                rarity: 'common',
                effect: (game, source) => {
                    source.block += 5;
                    game.log(`${source.name} gained 5 block.`, source === game.player ? 'player' : 'enemy');
                }
            },
            {
                id: 'quick_slash',
                name: 'Quick Slash',
                type: CARD_TYPES.ATTACK,
                cost: 1,
                description: 'Deal 4 damage. Draw a card.',
                rarity: 'common',
                effect: (game, source, target) => {
                    game.dealDamage(source, target, 4);
                    if (source === game.player) {
                        game.drawCard();
                    }
                }
            },
            {
                id: 'heavy_blow',
                name: 'Heavy Blow',
                type: CARD_TYPES.ATTACK,
                cost: 2,
                description: 'Deal 10 damage.',
                rarity: 'common',
                effect: (game, source, target) => {
                    game.dealDamage(source, target, 10);
                }
            },
            {
                id: 'iron_wave',
                name: 'Iron Wave',
                type: CARD_TYPES.ATTACK,
                cost: 1,
                description: 'Gain 5 block. Deal 5 damage.',
                rarity: 'common',
                effect: (game, source, target) => {
                    source.block += 5;
                    game.log(`${source.name} gained 5 block.`, source === game.player ? 'player' : 'enemy');
                    game.dealDamage(source, target, 5);
                }
            },
            {
                id: 'bash',
                name: 'Bash',
                type: CARD_TYPES.ATTACK,
                cost: 2,
                description: 'Deal 8 damage. Apply 2 Vulnerable.',
                rarity: 'uncommon',
                effect: (game, source, target) => {
                    game.dealDamage(source, target, 8);
                    target.vulnerable = (target.vulnerable || 0) + 2;
                    game.log(`${target.name} became Vulnerable for 2 turns.`, source === game.player ? 'player' : 'enemy');
                }
            },
            {
                id: 'cleave',
                name: 'Cleave',
                type: CARD_TYPES.ATTACK,
                cost: 1,
                description: 'Deal 8 damage. Deal 3 damage to yourself.',
                rarity: 'uncommon',
                effect: (game, source, target) => {
                    game.dealDamage(source, target, 8);
                    game.dealDamage(source, source, 3, true);
                }
            },
            {
                id: 'blood_ritual',
                name: 'Blood Ritual',
                type: CARD_TYPES.SKILL,
                cost: 0,
                description: 'Lose 3 HP. Gain 2 energy.',
                rarity: 'uncommon',
                effect: (game, source) => {
                    source.hp -= 3;
                    game.log(`${source.name} lost 3 HP.`, source === game.player ? 'player' : 'enemy');
                    source.energy += 2;
                    game.log(`${source.name} gained 2 energy.`, source === game.player ? 'player' : 'enemy');
                    game.updateStats();
                    
                    if (source.hp <= 0) {
                        if (source === game.player) {
                            game.gameOver(false);
                        } else {
                            game.enemyDefeated();
                        }
                    }
                }
            },
            {
                id: 'shrug_it_off',
                name: 'Shrug It Off',
                type: CARD_TYPES.DEFENSE,
                cost: 1,
                description: 'Gain 8 block. Draw a card.',
                rarity: 'uncommon',
                effect: (game, source) => {
                    source.block += 8;
                    game.log(`${source.name} gained 8 block.`, source === game.player ? 'player' : 'enemy');
                    if (source === game.player) {
                        game.drawCard();
                    }
                }
            },
            {
                id: 'uppercut',
                name: 'Uppercut',
                type: CARD_TYPES.ATTACK,
                cost: 2,
                description: 'Deal 13 damage.',
                rarity: 'uncommon',
                effect: (game, source, target) => {
                    game.dealDamage(source, target, 13);
                }
            },
            {
                id: 'sword_boomerang',
                name: 'Sword Boomerang',
                type: CARD_TYPES.ATTACK,
                cost: 1,
                description: 'Deal 3 damage 3 times.',
                rarity: 'uncommon',
                effect: (game, source, target) => {
                    for (let i = 0; i < 3; i++) {
                        game.dealDamage(source, target, 3);
                    }
                }
            },
            {
                id: 'berserk',
                name: 'Berserk',
                type: CARD_TYPES.SKILL,
                cost: 1,
                description: 'Gain 1 energy each turn. Take 2 damage at the start of your turn.',
                rarity: 'rare',
                effect: (game, source) => {
                    source.berserk = (source.berserk || 0) + 1;
                    game.log(`${source.name} will gain 1 energy each turn but take 2 damage.`, source === game.player ? 'player' : 'enemy');
                }
            },
            {
                id: 'offering',
                name: 'Offering',
                type: CARD_TYPES.SKILL,
                cost: 0,
                description: 'Lose 6 HP. Gain 2 energy and draw 3 cards.',
                rarity: 'rare',
                effect: (game, source) => {
                    source.hp -= 6;
                    game.log(`${source.name} lost 6 HP.`, source === game.player ? 'player' : 'enemy');
                    source.energy += 2;
                    game.log(`${source.name} gained 2 energy.`, source === game.player ? 'player' : 'enemy');
                    game.updateStats();
                    
                    if (source === game.player) {
                        for (let i = 0; i < 3; i++) {
                            game.drawCard();
                        }
                    }
                    
                    if (source.hp <= 0) {
                        if (source === game.player) {
                            game.gameOver(false);
                        } else {
                            game.enemyDefeated();
                        }
                    }
                }
            },
            {
                id: 'feed',
                name: 'Feed',
                type: CARD_TYPES.ATTACK,
                cost: 2,
                description: 'Deal 10 damage. If this kills the enemy, gain 3 max HP.',
                rarity: 'rare',
                effect: (game, source, target) => {
                    const targetHpBefore = target.hp;
                    game.dealDamage(source, target, 10);
                    
                    if (target.hp <= 0 && targetHpBefore > 0 && source === game.player) {
                        source.maxHp += 3;
                        source.hp += 3;
                        game.log(`${source.name} gained 3 maximum HP!`, 'reward');
                        game.updateStats();
                    }
                }
            },
            {
                id: 'impervious',
                name: 'Impervious',
                type: CARD_TYPES.DEFENSE,
                cost: 2,
                description: 'Gain 20 block.',
                rarity: 'rare',
                effect: (game, source) => {
                    source.block += 20;
                    game.log(`${source.name} gained 20 block.`, source === game.player ? 'player' : 'enemy');
                }
            },
            {
                id: 'limit_break',
                name: 'Limit Break',
                type: CARD_TYPES.SKILL,
                cost: 1,
                description: 'Double your strength.',
                rarity: 'rare',
                effect: (game, source) => {
                    if (source.strength) {
                        source.strength *= 2;
                        game.log(`${source.name}'s strength doubled to ${source.strength}!`, source === game.player ? 'player' : 'enemy');
                    } else {
                        game.log(`${source.name} has no strength to double.`, source === game.player ? 'player' : 'enemy');
                    }
                }
            }
        ];
        
        // Enemy definitions
        const ENEMIES = [
            {
                id: 'slime',
                name: 'Slime',
                hp: 14,
                maxHp: 14,
                energy: 3,
                maxEnergy: 3,
                deck: ['strike', 'strike', 'defend'],
                difficulty: 1
            },
            {
                id: 'goblin',
                name: 'Goblin',
                hp: 18,
                maxHp: 18,
                energy: 3,
                maxEnergy: 3,
                deck: ['strike', 'strike', 'quick_slash', 'defend'],
                difficulty: 1
            },
            {
                id: 'bandit',
                name: 'Bandit',
                hp: 22,
                maxHp: 22,
                energy: 3,
                maxEnergy: 3,
                deck: ['strike', 'quick_slash', 'heavy_blow', 'defend'],
                difficulty: 2
            },
            {
                id: 'skeleton_warrior',
                name: 'Skeleton Warrior',
                hp: 26,
                maxHp: 26,
                energy: 3,
                maxEnergy: 3,
                deck: ['strike', 'heavy_blow', 'bash', 'defend', 'defend'],
                difficulty: 2
            },
            {
                id: 'cultist',
                name: 'Cultist',
                hp: 30,
                maxHp: 30,
                energy: 3,
                maxEnergy: 3,
                deck: ['strike', 'blood_ritual', 'cleave', 'defend'],
                difficulty: 3
            },
            {
                id: 'knight',
                name: 'Knight',
                hp: 36,
                maxHp: 36,
                energy: 3,
                maxEnergy: 3,
                deck: ['heavy_blow', 'iron_wave', 'iron_wave', 'shrug_it_off', 'bash'],
                difficulty: 3
            },
            {
                id: 'dark_mage',
                name: 'Dark Mage',
                hp: 40,
                maxHp: 40,
                energy: 4,
                maxEnergy: 4,
                deck: ['blood_ritual', 'uppercut', 'cleave', 'berserk', 'defend', 'defend'],
                difficulty: 4
            },
            {
                id: 'dragon',
                name: 'Dragon',
                hp: 50,
                maxHp: 50,
                energy: 4,
                maxEnergy: 4,
                deck: ['heavy_blow', 'uppercut', 'cleave', 'sword_boomerang', 'berserk', 'offering'],
                difficulty: 5
            }
        ];
        
        // Game class
        class CardBattler {
            constructor() {
                this.player = {
                    name: 'Adventurer',
                    hp: 50,
                    maxHp: 50,
                    energy: 3,
                    maxEnergy: 3,
                    block: 0,
                    strength: 0,
                    deck: ['strike', 'strike', 'strike', 'defend', 'defend', 'defend', 'iron_wave', 'quick_slash'],
                    hand: [],
                    drawPile: [],
                    discardPile: []
                };
                
                this.enemy = null;
                this.currentFloor = 1;
                this.inBattle = false;
                this.battleTurn = 0;
                
                // DOM elements
                this.elements = {
                    playerName: document.getElementById('player-name'),
                    playerHp: document.getElementById('player-hp'),
                    playerEnergy: document.getElementById('player-energy'),
                    playerHand: document.getElementById('player-hand'),
                    player: document.getElementById('player'),
                    
                    enemyName: document.getElementById('enemy-name'),
                    enemyHp: document.getElementById('enemy-hp'),
                    enemyEnergy: document.getElementById('enemy-energy'),
                    enemy: document.getElementById('enemy'),
                    
                    logContainer: document.getElementById('log-container'),
                    floorInfo: document.getElementById('floor-info'),
                    
                    startBattleBtn: document.getElementById('start-battle-btn'),
                    nextFloorBtn: document.getElementById('next-floor-btn'),
                    viewDeckBtn: document.getElementById('view-deck-btn'),
                    
                    rewardContainer: document.getElementById('reward-container'),
                    rewardOptions: document.getElementById('reward-options'),
                    
                    gameOver: document.getElementById('game-over'),
                    gameOverMessage: document.getElementById('game-over-message'),
                    restartBtn: document.getElementById('restart-btn'),
                    
                    deckBuilder: document.getElementById('deck-builder'),
                    deckGrid: document.getElementById('deck-grid'),
                    deckStats: document.getElementById('deck-stats'),
                    playerStats: document.getElementById('player-stats'),
                    backToGameBtn: document.getElementById('back-to-game-btn'),
                };
                
                // Bind event listeners
                this.elements.startBattleBtn.addEventListener('click', () => this.startBattle());
                this.elements.nextFloorBtn.addEventListener('click', () => this.nextFloor());
                this.elements.viewDeckBtn.addEventListener('click', () => this.viewDeck());
                this.elements.restartBtn.addEventListener('click', () => this.restart());
                this.elements.backToGameBtn.addEventListener('click', () => this.hideViewDeck());
                
                // Initialize game
                this.setUpNewGame();
            }
            
            setUpNewGame() {
                this.currentFloor = 1;
                this.player = {
                    name: 'Adventurer',
                    hp: 50,
                    maxHp: 50,
                    energy: 3,
                    maxEnergy: 3,
                    block: 0,
                    strength: 0,
                    deck: ['strike', 'strike', 'strike', 'defend', 'defend', 'defend', 'iron_wave', 'quick_slash'],
                    hand: [],
                    drawPile: [],
                    discardPile: []
                };
                
                this.updateFloorInfo();
                this.generateEnemy();
                this.updateStats();
                this.log('Welcome to Card Battler! Prepare for battle...', 'system');
                
                this.elements.startBattleBtn.disabled = false;
                this.elements.nextFloorBtn.disabled = true;
                this.elements.rewardContainer.style.display = 'none';
                this.elements.gameOver.style.display = 'none';
                this.elements.deckBuilder.style.display = 'none';
            }
            
            generateEnemy() {
                // Choose enemy based on current floor
                const difficultyLevel = Math.min(Math.ceil(this.currentFloor / 2), 5);
                const possibleEnemies = ENEMIES.filter(e => e.difficulty <= difficultyLevel);
                const enemy = JSON.parse(JSON.stringify(possibleEnemies[Math.floor(Math.random() * possibleEnemies.length)]));
                
                // Scale enemy stats based on floor
                const scalingFactor = 1 + (this.currentFloor - 1) * 0.1;
                enemy.maxHp = Math.floor(enemy.maxHp * scalingFactor);
                enemy.hp = enemy.maxHp;
                
                // Add additional cards to enemy deck on higher floors
                if (this.currentFloor > 5) {
                    const additionalCards = Math.floor((this.currentFloor - 5) / 2);
                    for (let i = 0; i < additionalCards; i++) {
                        const randomCard = CARD_TEMPLATES[Math.floor(Math.random() * CARD_TEMPLATES.length)].id;
                        enemy.deck.push(randomCard);
                    }
                }
                
                enemy.hand = [];
                enemy.drawPile = [];
                enemy.discardPile = [];
                enemy.block = 0;
                
                this.enemy = enemy;
                this.elements.enemyName.textContent = enemy.name;
            }
            
            startBattle() {
                if (this.inBattle) return;
                
                this.inBattle = true;
                this.battleTurn = 0;
                
                // Clear hands, draw piles, discard piles
                this.player.hand = [];
                this.player.drawPile = [...this.player.deck];
                this.player.discardPile = [];
                this.player.block = 0;
                
                this.enemy.hand = [];
                this.enemy.drawPile = [...this.enemy.deck];
                this.enemy.discardPile = [];
                this.enemy.block = 0;
                
                // Shuffle draw piles
                this.shuffleArray(this.player.drawPile);
                this.shuffleArray(this.enemy.drawPile);
                
                // Reset energy
                this.player.energy = this.player.maxEnergy;
                this.enemy.energy = this.enemy.maxEnergy;
                
                // Update UI
                this.updateStats();
                this.elements.playerHand.innerHTML = '';
                
                this.log(`Battle against ${this.enemy.name} begins!`, 'system');
                this.elements.startBattleBtn.disabled = true;
                
                // Start first turn
                this.startPlayerTurn();
            }
            
            startPlayerTurn() {
                this.battleTurn++;
                this.log(`--- Turn ${this.battleTurn} ---`, 'system');
                
                // Reset energy
                this.player.energy = this.player.maxEnergy;
                
                // Apply any start-of-turn effects
                if (this.player.berserk) {
                    this.player.energy += this.player.berserk;
                    this.log(`${this.player.name} gains ${this.player.berserk} energy from Berserk.`, 'player');
                    
                    this.player.hp -= this.player.berserk * 2;
                    this.log(`${this.player.name} takes ${this.player.berserk * 2} damage from Berserk.`, 'player');
                    
                    if (this.player.hp <= 0) {
                        this.gameOver(false);
                        return;
                    }
                }
                
                // Reset block
                this.player.block = 0;
                
                // Draw cards
                for (let i = 0; i < 5; i++) {
                    this.drawCard();
                }
                
                this.updateStats();
                
                // Automated player turn
                setTimeout(() => this.playPlayerTurn(), 1000);
            }
            
            playPlayerTurn() {
                // Simulate the player playing cards automatically
                let cardPlayed = false;
                
                // Simple AI for player: play cards that we can afford, prioritizing attacks
                const attackCards = this.player.hand.filter(card => {
                    const template = this.getCardTemplate(card);
                    return template.type === CARD_TYPES.ATTACK && template.cost <= this.player.energy;
                });
                
                const defenseCards = this.player.hand.filter(card => {
                    const template = this.getCardTemplate(card);
                    return template.type === CARD_TYPES.DEFENSE && template.cost <= this.player.energy;
                });
                
                const skillCards = this.player.hand.filter(card => {
                    const template = this.getCardTemplate(card);
                    return template.type === CARD_TYPES.SKILL && template.cost <= this.player.energy;
                });
                
                // Play attacks first
                if (attackCards.length > 0) {
                    const cardIndex = Math.floor(Math.random() * attackCards.length);
                    const cardId = attackCards[cardIndex];
                    this.playCard(cardId, this.player, this.enemy);
                    cardPlayed = true;
                }
                // Then play defenses if enemy has high HP
                else if (defenseCards.length > 0 && this.enemy.hp > this.enemy.maxHp * 0.5) {
                    const cardIndex = Math.floor(Math.random() * defenseCards.length);
                    const cardId = defenseCards[cardIndex];
                    this.playCard(cardId, this.player, this.enemy);
                    cardPlayed = true;
                }
                // Then skills
                else if (skillCards.length > 0) {
                    const cardIndex = Math.floor(Math.random() * skillCards.length);
                    const cardId = skillCards[cardIndex];
                    this.playCard(cardId, this.player, this.enemy);
                    cardPlayed = true;
                }
                // Fallback to any card we can play
                else {
                    const playableCards = this.player.hand.filter(card => {
                        const template = this.getCardTemplate(card);
                        return template.cost <= this.player.energy;
                    });
                    
                    if (playableCards.length > 0) {
                        const cardIndex = Math.floor(Math.random() * playableCards.length);
                        const cardId = playableCards[cardIndex];
                        this.playCard(cardId, this.player, this.enemy);
                        cardPlayed = true;
                    }
                }
                
                if (cardPlayed) {
                    // Continue playing cards after a delay
                    setTimeout(() => this.playPlayerTurn(), 800);
                } else {
                    // End turn if no card can be played
                    this.log(`${this.player.name} ends their turn.`, 'player');
                    
                    // Discard hand
                    while (this.player.hand.length > 0) {
                        this.player.discardPile.push(this.player.hand.pop());
                    }
                    
                    this.updateUI();
                    
                    // Start enemy turn
                    setTimeout(() => this.startEnemyTurn(), 1000);
                }
            }
            
            startEnemyTurn() {
                // Check if enemy is already defeated
                if (this.enemy.hp <= 0) {
                    this.enemyDefeated();
                    return;
                }
                
                this.log(`${this.enemy.name}'s turn.`, 'enemy');
                
                // Reset energy
                this.enemy.energy = this.enemy.maxEnergy;
                
                // Apply any start-of-turn effects
                if (this.enemy.berserk) {
                    this.enemy.energy += this.enemy.berserk;
                    this.log(`${this.enemy.name} gains ${this.enemy.berserk} energy from Berserk.`, 'enemy');
                    
                    this.enemy.hp -= this.enemy.berserk * 2;
                    this.log(`${this.enemy.name} takes ${this.enemy.berserk * 2} damage from Berserk.`, 'enemy');
                    
                    if (this.enemy.hp <= 0) {
                        this.enemyDefeated();
                        return;
                    }
                }
                
                // Reset block
                this.enemy.block = 0;
                
                // Draw cards for enemy
                this.enemy.hand = [];
                for (let i = 0; i < 5; i++) {
                    if (this.enemy.drawPile.length === 0 && this.enemy.discardPile.length > 0) {
                        this.enemy.drawPile = [...this.enemy.discardPile];
                        this.enemy.discardPile = [];
                        this.shuffleArray(this.enemy.drawPile);
                        this.log(`${this.enemy.name} shuffles their discard pile into their draw pile.`, 'enemy');
                    }
                    
                    if (this.enemy.drawPile.length > 0) {
                        const card = this.enemy.drawPile.pop();
                        this.enemy.hand.push(card);
                    }
                }
                
                this.updateStats();
                
                // Play enemy turn
                setTimeout(() => this.playEnemyTurn(), 1000);
            }
            
            playEnemyTurn() {
                // Check if enemy is already defeated
                if (this.enemy.hp <= 0) {
                    this.enemyDefeated();
                    return;
                }
                
                // Simple AI for enemy: play cards that we can afford
                let cardPlayed = false;
                
                const playableCards = this.enemy.hand.filter(card => {
                    const template = this.getCardTemplate(card);
                    return template.cost <= this.enemy.energy;
                });
                
                if (playableCards.length > 0 && this.enemy.hp > 0) {
                    const cardIndex = Math.floor(Math.random() * playableCards.length);
                    const cardId = playableCards[cardIndex];
                    const cardTemplate = this.getCardTemplate(cardId);
                    
                    // Remove card from hand
                    this.enemy.hand.splice(this.enemy.hand.indexOf(cardId), 1);
                    this.enemy.discardPile.push(cardId);
                    
                    // Pay cost
                    this.enemy.energy -= cardTemplate.cost;
                    
                    // Play effect
                    this.log(`${this.enemy.name} plays ${cardTemplate.name}.`, 'enemy');
                    cardTemplate.effect(this, this.enemy, this.player);
                    
                    this.updateStats();
                    
                    // Check again if enemy was defeated by their own card (e.g. self-damage)
                    if (this.enemy.hp <= 0) {
                        this.enemyDefeated();
                        return;
                    }
                    
                    // Add a visual effect
                    this.elements.enemy.classList.add('flash');
                    setTimeout(() => {
                        this.elements.enemy.classList.remove('flash');
                    }, 300);
                    
                    cardPlayed = true;
                    
                    // Check if player is defeated
                    if (this.player.hp <= 0) {
                        this.gameOver(false);
                        return;
                    }
                    
                    // Continue playing cards after a delay
                    setTimeout(() => this.playEnemyTurn(), 800);
                } else {
                    // End turn if no card can be played
                    this.log(`${this.enemy.name} ends their turn.`, 'enemy');
                    
                    // Discard hand
                    this.enemy.discardPile.push(...this.enemy.hand);
                    this.enemy.hand = [];
                    
                    // Start player turn
                    setTimeout(() => this.startPlayerTurn(), 1000);
                }
            }
            
            playCard(cardId, source, target) {
                const cardTemplate = this.getCardTemplate(cardId);
                
                // Remove card from hand
                source.hand.splice(source.hand.indexOf(cardId), 1);
                source.discardPile.push(cardId);
                
                // Pay cost
                source.energy -= cardTemplate.cost;
                
                // Play effect
                this.log(`${source.name} plays ${cardTemplate.name}.`, source === this.player ? 'player' : 'enemy');
                cardTemplate.effect(this, source, target);
                
                this.updateUI();
                
                // Add a visual effect for the player
                if (source === this.player) {
                    // Animate card being played
                    const cardElements = document.querySelectorAll('.card');
                    cardElements.forEach(card => {
                        if (card.dataset.cardId === cardId) {
                            card.classList.add('flash');
                            setTimeout(() => {
                                card.remove();
                            }, 300);
                        }
                    });
                }
            }
            
            drawCard() {
                if (this.player.drawPile.length === 0 && this.player.discardPile.length > 0) {
                    this.player.drawPile = [...this.player.discardPile];
                    this.player.discardPile = [];
                    this.shuffleArray(this.player.drawPile);
                    this.log(`${this.player.name} shuffles their discard pile into their draw pile.`, 'player');
                }
                
                if (this.player.drawPile.length > 0) {
                    const card = this.player.drawPile.pop();
                    this.player.hand.push(card);
                    this.log(`${this.player.name} draws a card.`, 'player');
                    this.updateUI();
                } else {
                    this.log(`${this.player.name} has no cards to draw.`, 'player');
                }
            }
            
            dealDamage(source, target, amount, ignoreBlock = false) {
                // Apply strength
                if (source.strength) {
                    amount += source.strength;
                }
                
                // Apply vulnerable
                if (target.vulnerable > 0) {
                    amount = Math.floor(amount * 1.5);
                    target.vulnerable--;
                    if (target.vulnerable === 0) {
                        this.log(`${target.name} is no longer Vulnerable.`, source === this.player ? 'player' : 'enemy');
                    }
                }
                
                let damageDealt = amount;
                
                // Apply block if not ignoring
                if (!ignoreBlock && target.block > 0) {
                    if (target.block >= amount) {
                        target.block -= amount;
                        damageDealt = 0;
                        this.log(`${target.name}'s block absorbs ${amount} damage.`, source === this.player ? 'player' : 'enemy');
                    } else {
                        damageDealt = amount - target.block;
                        this.log(`${target.name}'s block absorbs ${target.block} damage.`, source === this.player ? 'player' : 'enemy');
                        target.block = 0;
                    }
                }
                
                // Apply damage
                if (damageDealt > 0) {
                    target.hp -= damageDealt;
                    this.log(`${source.name} deals ${damageDealt} damage to ${target.name}.`, source === this.player ? 'player' : 'enemy');
                    
                    // Add visual effect
                    if (target === this.enemy) {
                        this.elements.enemy.classList.add('shake');
                        setTimeout(() => {
                            this.elements.enemy.classList.remove('shake');
                        }, 500);
                        
                        // Show damage number
                        const damageText = document.createElement('div');
                        damageText.className = 'damage-text';
                        damageText.textContent = `-${damageDealt}`;
                        damageText.style.left = `${Math.random() * 200 + 300}px`;
                        damageText.style.top = `${Math.random() * 50 + 100}px`;
                        document.body.appendChild(damageText);
                        
                        setTimeout(() => {
                            damageText.remove();
                        }, 1000);
                    } else {
                        this.elements.player.classList.add('shake');
                        setTimeout(() => {
                            this.elements.player.classList.remove('shake');
                        }, 500);
                        
                        // Show damage number
                        const damageText = document.createElement('div');
                        damageText.className = 'damage-text';
                        damageText.textContent = `-${damageDealt}`;
                        damageText.style.left = `${Math.random() * 200 + 300}px`;
                        damageText.style.top = `${Math.random() * 50 + 250}px`;
                        document.body.appendChild(damageText);
                        
                        setTimeout(() => {
                            damageText.remove();
                        }, 1000);
                    }
                }
                
                // Check for defeat
                if (target.hp <= 0) {
                    target.hp = 0;
                    if (target === this.enemy) {
                        // Immediately end battle and show rewards
                        this.inBattle = false;
                        this.enemyDefeated();
                        return true; // Signal that enemy was defeated
                    } else {
                        this.gameOver(false);
                        return true; // Signal player was defeated
                    }
                }
                
                return false; // No one was defeated
                
                this.updateStats();
            }
            
            enemyDefeated() {
                this.inBattle = false;
                this.log(`${this.enemy.name} has been defeated!`, 'system');
                
                // Show reward
                this.showReward();
                
                // Enable next floor button
                this.elements.nextFloorBtn.disabled = false;
            }
            
            showReward() {
                this.elements.rewardContainer.style.display = 'flex';
                this.elements.rewardOptions.innerHTML = '';
                
                // Generate 3 random cards as rewards
                const rewardCards = [];
                const rarities = ['common', 'uncommon', 'rare'];
                const rarity = rarities[Math.min(Math.floor(this.currentFloor / 3), 2)];
                
                // Higher chance of better cards on higher floors
                let commonChance = 0.7 - (this.currentFloor * 0.03);
                let uncommonChance = 0.25 + (this.currentFloor * 0.01);
                let rareChance = 0.05 + (this.currentFloor * 0.02);
                
                // Normalize chances
                const total = commonChance + uncommonChance + rareChance;
                commonChance /= total;
                uncommonChance /= total;
                rareChance /= total;
                
                for (let i = 0; i < 3; i++) {
                    let selectedRarity;
                    const roll = Math.random();
                    
                    if (roll < commonChance) {
                        selectedRarity = 'common';
                    } else if (roll < commonChance + uncommonChance) {
                        selectedRarity = 'uncommon';
                    } else {
                        selectedRarity = 'rare';
                    }
                    
                    const possibleCards = CARD_TEMPLATES.filter(card => card.rarity === selectedRarity);
                    let cardTemplate = possibleCards[Math.floor(Math.random() * possibleCards.length)];
                    
                    // Avoid duplicates in rewards
                    while (rewardCards.includes(cardTemplate.id)) {
                        cardTemplate = possibleCards[Math.floor(Math.random() * possibleCards.length)];
                    }
                    
                    rewardCards.push(cardTemplate.id);
                    
                    // Create card element
                    const cardElement = this.createCardElement(cardTemplate);
                    cardElement.addEventListener('click', () => {
                        this.addCardToDeck(cardTemplate.id);
                        this.elements.rewardContainer.style.display = 'none';
                    });
                    
                    this.elements.rewardOptions.appendChild(cardElement);
                }
                
                // Add skip reward option
                const skipButton = document.createElement('button');
                skipButton.textContent = 'Skip Reward';
                skipButton.addEventListener('click', () => {
                    this.elements.rewardContainer.style.display = 'none';
                });
                this.elements.rewardOptions.appendChild(skipButton);
            }
            
            addCardToDeck(cardId) {
                this.player.deck.push(cardId);
                const cardTemplate = this.getCardTemplate(cardId);
                this.log(`Added ${cardTemplate.name} to your deck!`, 'reward');
            }
            
            nextFloor() {
                this.currentFloor++;
                this.updateFloorInfo();
                this.generateEnemy();
                this.updateStats();
                
                // Heal player slightly between floors
                const healAmount = Math.floor(this.player.maxHp * 0.1);
                this.player.hp = Math.min(this.player.hp + healAmount, this.player.maxHp);
                this.log(`You rest between floors and recover ${healAmount} HP.`, 'system');
                
                this.elements.startBattleBtn.disabled = false;
                this.elements.nextFloorBtn.disabled = true;
                
                // Win condition
                if (this.currentFloor > 10) {
                    this.gameOver(true);
                }
            }
            
            gameOver(victory) {
                this.inBattle = false;
                this.elements.gameOver.style.display = 'block';
                
                if (victory) {
                    this.elements.gameOverMessage.textContent = `Victory! You conquered the ${this.currentFloor} floors!`;
                    this.log('Congratulations! You have won the game!', 'system');
                } else {
                    this.elements.gameOverMessage.textContent = `Defeat! You made it to floor ${this.currentFloor}.`;
                    this.log('Game over! You have been defeated.', 'system');
                }
                
                this.elements.startBattleBtn.disabled = true;
                this.elements.nextFloorBtn.disabled = true;
            }
            
            viewDeck() {
                this.elements.deckBuilder.style.display = 'flex';
                this.updateDeckView();
            }
            
            hideViewDeck() {
                this.elements.deckBuilder.style.display = 'none';
            }
            
            updateDeckView() {
                this.elements.deckGrid.innerHTML = '';
                this.elements.deckStats.innerHTML = '';
                this.elements.playerStats.innerHTML = '';
                
                // Add player stats
                const statsHTML = `
                    <div class="player-stat">
                        <div>HP</div>
                        <div class="stat-value">${this.player.hp}/${this.player.maxHp}</div>
                    </div>
                    <div class="player-stat">
                        <div>Energy</div>
                        <div class="stat-value">${this.player.maxEnergy}</div>
                    </div>
                    <div class="player-stat">
                        <div>Floor</div>
                        <div class="stat-value">${this.currentFloor}</div>
                    </div>
                `;
                this.elements.playerStats.innerHTML = statsHTML;
                
                // Count card types
                const cardCounts = {
                    [CARD_TYPES.ATTACK]: 0,
                    [CARD_TYPES.DEFENSE]: 0,
                    [CARD_TYPES.SKILL]: 0
                };
                
                // Group cards by ID
                const cardGroups = {};
                
                this.player.deck.forEach(cardId => {
                    const template = this.getCardTemplate(cardId);
                    cardCounts[template.type]++;
                    
                    if (!cardGroups[cardId]) {
                        cardGroups[cardId] = 1;
                    } else {
                        cardGroups[cardId]++;
                    }
                });
                
                // Display deck stats
                const deckStatsHTML = `
                    <div>Deck Size: ${this.player.deck.length}</div>
                    <div>Attacks: ${cardCounts[CARD_TYPES.ATTACK]}</div>
                    <div>Defenses: ${cardCounts[CARD_TYPES.DEFENSE]}</div>
                    <div>Skills: ${cardCounts[CARD_TYPES.SKILL]}</div>
                `;
                this.elements.deckStats.innerHTML = deckStatsHTML;
                
                // Display cards
                Object.entries(cardGroups).forEach(([cardId, count]) => {
                    const template = this.getCardTemplate(cardId);
                    const cardElement = this.createCardElement(template);
                    
                    // Add count badge
                    if (count > 1) {
                        const countBadge = document.createElement('div');
                        countBadge.textContent = `x${count}`;
                        countBadge.style.position = 'absolute';
                        countBadge.style.top = '5px';
                        countBadge.style.right = '5px';
                        countBadge.style.background = '#333';
                        countBadge.style.padding = '2px 5px';
                        countBadge.style.borderRadius = '3px';
                        countBadge.style.fontSize = '12px';
                        cardElement.appendChild(countBadge);
                    }
                    
                    this.elements.deckGrid.appendChild(cardElement);
                });
            }
            
            restart() {
                this.setUpNewGame();
            }
            
            getCardTemplate(id) {
                return CARD_TEMPLATES.find(card => card.id === id);
            }
            
            createCardElement(cardTemplate) {
                const card = document.createElement('div');
                card.className = `card ${cardTemplate.type}`;
                card.dataset.cardId = cardTemplate.id;
                
                const cost = document.createElement('div');
                cost.className = 'card-cost';
                cost.textContent = cardTemplate.cost;
                
                const name = document.createElement('div');
                name.className = 'card-name';
                name.textContent = cardTemplate.name;
                
                const description = document.createElement('div');
                description.className = 'card-description';
                description.textContent = cardTemplate.description;
                
                const type = document.createElement('div');
                type.className = 'card-type';
                type.textContent = cardTemplate.type.charAt(0).toUpperCase() + cardTemplate.type.slice(1);
                
                card.appendChild(cost);
                card.appendChild(name);
                card.appendChild(description);
                card.appendChild(type);
                
                return card;
            }
            
            updateUI() {
                // Update player hand
                this.elements.playerHand.innerHTML = '';
                this.player.hand.forEach(cardId => {
                    const cardTemplate = this.getCardTemplate(cardId);
                    const cardElement = this.createCardElement(cardTemplate);
                    this.elements.playerHand.appendChild(cardElement);
                });
                
                this.updateStats();
            }
            
            updateStats() {
                // Update player stats
                this.elements.playerHp.textContent = `${this.player.hp}/${this.player.maxHp}`;
                if (this.player.block > 0) {
                    this.elements.playerHp.textContent += ` (${this.player.block} Block)`;
                }
                this.elements.playerEnergy.textContent = `${this.player.energy}/${this.player.maxEnergy}`;
                
                // Update enemy stats
                this.elements.enemyHp.textContent = `${this.enemy.hp}/${this.enemy.maxHp}`;
                if (this.enemy.block > 0) {
                    this.elements.enemyHp.textContent += ` (${this.enemy.block} Block)`;
                }
                this.elements.enemyEnergy.textContent = `${this.enemy.energy}/${this.enemy.maxEnergy}`;
            }
            
            updateFloorInfo() {
                this.elements.floorInfo.textContent = `Floor ${this.currentFloor}`;
            }
            
            log(message, type = 'system') {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = message;
                
                this.elements.logContainer.appendChild(logEntry);
                this.elements.logContainer.scrollTop = this.elements.logContainer.scrollHeight;
            }
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }
        
        // Initialize game when page loads
        window.onload = function() {
            const game = new CardBattler();
        };
    </script>
</body>
</html>